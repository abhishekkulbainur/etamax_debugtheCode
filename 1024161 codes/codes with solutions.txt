/*1. Find maximum of two numbers
Fix: Changed the assignment operator = to the comparison operator >.

C
#include <stdio.h>

int main() {
    int a = 10, b = 20;
    if (a > b)
        printf("%d", a);
    else
        printf("%d", b);
    return 0;
}
2. Reverse a number
Fix: Changed n / 0 (undefined behavior/crash) to n / 10.

C
#include <stdio.h>

int main() {
    int n = 123, rev = 0;
    while (n > 0) {
        rev = rev * 10 + n % 10;
        n = n / 10;
    }
    printf("%d", rev);
    return 0;
}
3. Calculate power using recursion
Fix: Changed base case return to 1 (identity for multiplication) and added b-1 to the recursive call.

C
#include <stdio.h>

int power(int a, int b) {
    if (b == 0)
        return 1;
    return a * power(a, b - 1);
}

int main() {
    printf("%d", power(2, 3));
    return 0;
}
4. Find length of string
Fix: Used strlen() from string.h. sizeof() would return the size of the array (6), including the null terminator.

C
#include <stdio.h>
#include <string.h>

int main() {
    char str[] = "Hello";
    int len = strlen(str);
    printf("%d", len);
    return 0;
}
5. Swap numbers without temp
Fix: The third step must be a = a - b to isolate the original value of b.

C
#include <stdio.h>

int main() {
    int a = 5, b = 10;
    a = a + b; // 15
    b = a - b; // 5
    a = a - b; // 10
    printf("%d %d", a, b);
    return 0;
}
6. Print even numbers
Fix: Used the equality operator == instead of assignment =.

C
#include <stdio.h>

int main() {
    for (int i = 1; i <= 10; i++) {
        if (i % 2 == 0)
            printf("%d ", i);
    }
    return 0;
}
7. Check palindrome string
Fix: strcmp returns 0 when strings are identical.

C
#include <stdio.h>
#include <string.h>

int main() {
    char s1[] = "madam";
    char s2[10];
    strcpy(s2, s1);
    
    // Note: strrev is not standard C. Manually reversing:
    int len = strlen(s1);
    for (int i = 0; i < len / 2; i++) {
        char temp = s1[i];
        s1[i] = s1[len - 1 - i];
        s1[len - 1 - i] = temp;
    }

    if (strcmp(s1, s2) == 0)
        printf("Palindrome");
    else
        printf("Not");
    return 0;
}
8. Count vowels in string
Fix: Each character comparison must be independent.

C
#include <stdio.h>

int main() {
    char s[] = "hello";
    int count = 0;
    for (int i = 0; s[i] != '\0'; i++) {
        char c = s[i];
        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')
            count++;
    }
    printf("%d", count);
    return 0;
}
9. Access array using pointer
Fix: Point to the array base a (which is &a[0]), not the value a[0].

C
#include <stdio.h>

int main() {
    int a[] = {1, 2, 3};
    int *p;
    p = a; 
    printf("%d", *p);
    return 0;
}
10. Print ASCII values
Fix: Used %d format specifier to print the numerical value of the character.

C
#include <stdio.h>

int main() {
    char ch = 'A';
    printf("%d", ch);
    return 0;
}
11. Find factorial using loop
Fix: Initialized fact to 1 because 0 multiplied by anything is 0.

C
#include <stdio.h>

int main() {
    int n = 5, fact = 1;
    for (int i = 1; i <= n; i++)
        fact *= i;
    printf("%d", fact);
    return 0;
}
12. Sum of array elements
Fix: Initialized sum to 0 to avoid adding to a garbage value.

C
#include <stdio.h>

int main() {
    int a[] = {1, 2, 3};
    int sum = 0;
    for (int i = 0; i < 3; i++)
        sum = sum + a[i];
    printf("%d", sum);
    return 0;
}
13. Use structure correctly
Fix: Data must be assigned to the structure member before printing.

C
#include <stdio.h>

struct Emp {
    int id;
};

int main() {
    struct Emp e;
    e.id = 101; 
    printf("%d", e.id);
    return 0;
}
14. Read integer from user
Fix: Used %d for int. %f is for float.

C
#include <stdio.h>

int main() {
    int x;
    scanf("%d", &x);
    printf("%d", x);
    return 0;
}
15. Find largest in array
Fix: Changed < to > to update max when a bigger number is found.

C
#include <stdio.h>

int main() {
    int a[] = {2, 9, 1};
    int max = a[0];
    for (int i = 1; i < 3; i++)
        if (a[i] > max)
            max = a[i];
    printf("%d", max);
    return 0;
}
16. Demonstrate pointer increment
Fix: Used parentheses (*p)++ to increment the value pointed at, rather than the address.

C
#include <stdio.h>

int main() {
    int a = 10;
    int *p = &a;
    (*p)++; 
    printf("%d", a);
    return 0;
}
17. Check odd or even (Bitwise)
Fix: Added parentheses (n & 1) because == has higher precedence than &.

C
#include <stdio.h>

int main() {
    int n = 7;
    if ((n & 1) == 0)
        printf("Even");
    else
        printf("Odd");
    return 0;
}
18. Use macro safely
Fix: Added parentheses to ensure the order of operations is correct for expressions like 1+2.

C
#include <stdio.h>

#define CUBE(x) ((x)*(x)*(x))

int main() {
    printf("%d", CUBE(1 + 2));
    return 0;
}
19. Print pattern
Fix: Removed the semicolon after the inner loop which was causing a blank loop.

C
#include <stdio.h>

int main() {
    for (int i = 1; i <= 3; i++) {
        for (int j = 1; j <= i; j++)
            printf("*");
        printf("\n");
    }
    return 0;
}
20. File open
Fix: Use "w" mode to write to a file using fprintf.

C
#include <stdio.h>

int main() {
    FILE *fp;
    fp = fopen("data.txt", "w");
    if (fp != NULL) {
        fprintf(fp, "Hello");
        fclose(fp);
    }
    return 0;
}
21. Check Armstrong number
Fix: For a 3-digit number, sum the cubes r*r*r.

C
#include <stdio.h>

int main() {
    int n = 153, sum = 0, temp = n;
    while (temp > 0) {
        int r = temp % 10;
        sum = sum + (r * r * r);
        temp = temp / 10;
    }
    if (sum == n)
        printf("Armstrong");
    else
        printf("Not");
    return 0;
}
22. Find GCD
Fix: Changed || to && to ensure i stays within bounds of both numbers.

C
#include <stdio.h>

int main() {
    int a = 12, b = 18, gcd;
    for (int i = 1; i <= a && i <= b; i++) {
        if (a % i == 0 && b % i == 0)
            gcd = i;
    }
    printf("%d", gcd);
    return 0;
}
23. Check perfect number
Fix: Sum the divisor i, not the original number n.

C
#include <stdio.h>

int main() {
    int n = 6, sum = 0;
    for (int i = 1; i < n; i++) {
        if (n % i == 0)
            sum = sum + i;
    }
    if (sum == n)
        printf("Perfect");
    else
        printf("Not");
    return 0;
}
24. Fibonacci series
Fix: Update b with the new calculated value c.

C
#include <stdio.h>

int main() {
    int a = 0, b = 1, c;
    printf("%d %d ", a, b);
    for (int i = 0; i < 5; i++) {
        c = a + b;
        printf("%d ", c);
        a = b;
        b = c;
    }
    return 0;
}
25. Count digits
Fix: Use division / 10 to reduce the number, not modulo.

C
#include <stdio.h>

int main() {
    int n = 12345, count = 0;
    while (n > 0) {
        count++;
        n = n / 10;
    }
    printf("%d", count);
    return 0;
}
26. Find LCM
Fix: LCM must be divisible by both a AND b.

C
#include <stdio.h>

int main() {
    int a = 4, b = 6, max;
    max = (a > b) ? a : b;
    while (1) {
        if (max % a == 0 && max % b == 0)
            break;
        max++;
    }
    printf("%d", max);
    return 0;
}
27. Binary to Decimal
Fix: The base should double (power of 2) each iteration.

C
#include <stdio.h>

int main() {
    int n = 1011, dec = 0, base = 1;
    while (n > 0) {
        int r = n % 10;
        dec = dec + r * base;
        base = base * 2;
        n = n / 10;
    }
    printf("%d", dec);
    return 0;
}
28. Check strong number
Fix: Calculate the factorial of the digit r, not the remaining number temp.

C
#include <stdio.h>

int fact(int x) {
    int f = 1;
    for (int i = 1; i <= x; i++)
        f = f * i;
    return f;
}

int main() {
    int n = 145, sum = 0, temp = n;
    while (temp > 0) {
        int r = temp % 10;
        sum = sum + fact(r);
        temp = temp / 10;
    }
    if (sum == n)
        printf("Strong");
    else
        printf("Not");
    return 0;
}
29. Find second smallest element
Fix: Added a condition to check for smin if the number is between min and the current smin.

C
#include <stdio.h>
#include <limits.h>

int main() {
    int a[] = {4, 1, 3, 2};
    int min = INT_MAX, smin = INT_MAX;
    for (int i = 0; i < 4; i++) {
        if (a[i] < min) {
            smin = min;
            min = a[i];
        } else if (a[i] < smin && a[i] != min) {
            smin = a[i];
        }
    }
    printf("%d", smin);
    return 0;
}
30. Check anagram
Fix: Added the logic to sort characters or count frequencies. Here we use frequency counting.

C
#include <stdio.h>
#include <string.h>

int main() {
    char s1[] = "listen";
    char s2[] = "silent";
    int count[256] = {0};
    int i, flag = 1;

    if (strlen(s1) != strlen(s2)) {
        printf("Not Anagram");
        return 0;
    }

    for (i = 0; s1[i] != '\0'; i++) {
        count[(int)s1[i]]++;
        count[(int)s2[i]]--;
    }

    for (i = 0; i < 256; i++) {
        if (count[i] != 0) {
            flag = 0;
            break;
        }
    }

    if (flag) printf("Anagram");
    else printf("Not Anagram");
    return 0;
}
31. Find duplicate elements
Fix: Used == for comparison.

C
#include <stdio.h>

int main() {
    int a[] = {1, 2, 3, 2};
    for (int i = 0; i < 4; i++) {
        for (int j = i + 1; j < 4; j++) {
            if (a[i] == a[j])
                printf("%d", a[i]);
        }
    }
    return 0;
}
32. Reverse array
Fix: Used correct index n-i-1 for swapping.

C
#include <stdio.h>

int main() {
    int a[] = {1, 2, 3, 4};
    int n = 4;
    for (int i = 0; i < n / 2; i++) {
        int temp = a[i];
        a[i] = a[n - i - 1];
        a[n - i - 1] = temp;
    }
    for (int i = 0; i < n; i++) printf("%d ", a[i]);
    return 0;
}
33. Count set bits
Fix: Added parentheses for precedence.

C
#include <stdio.h>

int main() {
    int n = 7, count = 0;
    while (n) {
        if ((n & 1) == 1)
            count++;
        n = n >> 1;
    }
    printf("%d", count);
    return 0;
}
34. Check leap year
Fix: Added the full condition: divisible by 4, but not 100, unless divisible by 400.

C
#include <stdio.h>

int main() {
    int y = 2000;
    if ((y % 4 == 0 && y % 100 != 0) || (y % 400 == 0))
        printf("Leap");
    else
        printf("Not");
    return 0;
}
35. Find majority element
Fix: Completed logic to check counts.

C
#include <stdio.h>

int main() {
    int a[] = {2, 2, 1, 2, 3};
    int n = 5;
    for (int i = 0; i < n; i++) {
        int count = 0;
        for (int j = 0; j < n; j++) {
            if (a[i] == a[j]) count++;
        }
        if (count > n / 2) {
            printf("%d", a[i]);
            return 0;
        }
    }
    return 0;
}
36. Matrix addition
Fix: Changed * to +.

C
#include <stdio.h>

int main() {
    int a[2][2] = {{1, 2}, {3, 4}};
    int b[2][2] = {{5, 6}, {7, 8}};
    int c[2][2];
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 2; j++) {
            c[i][j] = a[i][j] + b[i][j];
            printf("%d ", c[i][j]);
        }
        printf("\n");
    }
    return 0;
}
37. Check power of 2
Fix: Replaced logic; for a power of two, n & (n-1) is 0.

C
#include <stdio.h>

int main() {
    int n = 16;
    if (n > 0 && (n & (n - 1)) == 0)
        printf("Power of 2");
    else
        printf("Not");
    return 0;
}
38. Find missing number
Fix: Corrected formula for sum of first n natural numbers.

C
#include <stdio.h>

int main() {
    int a[] = {1, 2, 4, 5};
    int n = 5, sum = 0;
    for (int i = 0; i < 4; i++)
        sum += a[i];
    int total = n * (n + 1) / 2;
    printf("%d", total - sum);
    return 0;
}
39. Stack overflow check
Fix: Added a base condition (though usually, this is used as an example of what causes overflow).

C
#include <stdio.h>

void fun(int n) {
    if (n == 0) return;
    fun(n - 1);
}

int main() {
    fun(10);
    printf("Finished safely");
    return 0;
}
40. Circular queue condition
Fix: Corrected condition for "Full" (when rear is one behind front).

C
#include <stdio.h>

int main() {
    int front = 0, rear = 4, size = 5;
    if ((rear + 1) % size == front)
        printf("Full");
    return 0;
}*/